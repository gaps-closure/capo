/* Entire file to be autogenerated by CAPO */

#ifndef _PURPLE_RPC_
#define _PURPLE_RPC_
#include "xdcomms.h"
#include "codec.h"

# define MUX_NEXTRPC    1
# define SEC_NEXTRPC    1
# define MUX_OKAY       2
# define SEC_OKAY       2
# define MUX_REQUESTA   1
# define SEC_REQUESTA   1
# define MUX_RESPONSEA  2
# define SEC_RESPONSEA  2

# define INURI  "ipc:///tmp/test1subpurple"
# define OUTURI "ipc:///tmp/test1pubpurple"

/* When receiving from the other side, only level changes 
(our level is the remote level of our peer). Preserve
the rest of CLE json for data provenance */

#pragma cle def TAG_RESPONSE_GET_A {"level":"purple",\
  "cdf": [\
    {"remotelevel":"purple", \
     "direction": "egress", \
     "guardhint": { "operation": "allow", \
                    "gapstag": [2,2,4] }} \
  ] }

#pragma cle def TAG_REQUEST_GET_A {"level":"purple",\
  "cdf": [\
    {"remotelevel":"orange", \
     "direction": "egress", \
     "guardhint": { "operation": "allow", \
                    "gapstag": [1,1,3] }} \
  ] }

#pragma cle def TAG_OKAY {"level":"purple",\
  "cdf": [\
    {"remotelevel":"purple", \
     "direction": "egress", \
     "guardhint": { "operation": "allow", \
                    "gapstag": [2,2,2] }} \
  ] }

#pragma cle def TAG_NEXTRPC {"level":"purple",\
  "cdf": [\
    {"remotelevel":"orange", \
     "direction": "egress", \
     "guardhint": { "operation": "allow", \
                    "gapstag": [1,1,1] }} \
  ] }

#pragma cle def XDLINKAGE_RPC_GET_A {"level":"purple",\
 "cdf": [\
    {"remotelevel":"orange", \
     "direction": "bidirectional", \
     "guardhint": { "operation": "allow"}, \
     "argtaints": [], \
     "codtaints": ["TAG_REQUEST_GET_A", "TAG_RESPONSE_GET_A"], \
     "rettaints": ["TAG_RESPONSE_GET_A"] \
    } \
  ] }

extern void   _master_rpc_init();
extern double _rpc_get_a();

#endif /* _PURPLE_RPC_ */

