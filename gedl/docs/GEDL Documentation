GEDL will be produced in JSON format as a file named "Enclaves.gedl"
An example GEDL file would look like:
{"gedl": [
	{
		"caller": "enclave1",
		"callee": "enclave2",
		"calls": [
			{
				"func":		"sampleFunc",
				"return":	{"type": "double"},
				"diode":	false,
				"params": [
					{"type": "int", "name": "sampleInt", "dir": "in"}, 
					{"type": "double", "name": "sampleDoubleArray", "dir": "inout", "sz":[15]} 
				],
				"occurs": [
					{"file": "/sample/Enclave1/Path/Enclave1File.c", "lines": [44]},
                    {"file": "/sample/Enclave1/Path/Enclave1File2.c", "lines": [15,205]}

				]
			},
            {
				"func":		"sampleFunc2",
				"return":	{"type": "int"},
				"diode":	false,
				"params": [
				],
				"occurs": [
					{"file": "/sample/Enclave1/Path/Enclave1File.c", "lines": [45]}
				]
			}
		]
	},
    {
		"caller": "enclave2",
		"callee": "enclave3",
		"calls": [
			{
				"func":		"sampleFunc3",
				"return":	{"type": "void"},
				"diode":	false,
				"params": [
					{"type": "uint8", "name": "sampleUInt8", "dir": "in"} 
				],
				"occurs": [
                    {"file": "/sample/Enclave1/Path/Enclave2File.c", "lines": [55,87]}
				]
			}
		]
	}
]}
Key Table:
gedl:   
        The top level key, contains one object for each unique ordered
        pair of enclaves with cross-domain calls. This is determined by
        checking which importedFunctions from an imported_func.txt file
        are also present in a defined_func.txt of a different enclave.
        These files are generated by compiling the contents of the indicated
        directories into .ll files with names matching the directories, then
        running opt with -llvm-test and -prefix flags on each file.

        Represented by a JSON array of objects of arbitrary size.
    caller: 
            The name of the enclave making the cross-domain call. 
            This will match the name of the directory containing the
            imported_func.txt file for the considered importedFunction.

            Represented by a double quote (") enclosed string that conforms
            to linux filename restrictions and in all lowercase.
    callee:
            The name of the enclave where the cross-domain call is 
            defined. This will match the name of the directory containing
            the defined_func.txt file for the considered importedFuncion.
    
            Represented by a double quote (") enclosed string that conforms
            to linux filename restrictions and in all lowercase.
    calls:  
            An array containing one object for each cross-domain function 
            called from "caller" and defined in "callee". This is determined
            by creating an entry for each unique function in the "caller" 
            imported_func.txt file that is present in "callee" defined_func.txt

            Represented by a JSON array of objects of arbitrary size.
    func:
            The function name of the cross-domain call. Determined by name in
            imported_func.txt.

            Represented by a double quote (") enclosed string conforming to
            c/c++ function name restrictions.
    return:
            An object defining the type of the function's return. 

            Represented by a JSON object with a single key type
        type:   
                A variable type representing the type of the function's return
                value. Determined by querying DIUtils.getDITypeName(), which 
                uses debug information to check the return type of the function. 

                Represented by a double quote (") enclosed string that is one of
                IDL's supported C types [double, ffloat, int8, uint8, int16, uint16,
                int32, uint32, int64, uint64] and not a pointer (no *)
    diode:  
            Boolean value determining if function is a diode or not, meaning it must
            wait for a response if it is or continue without a response if not. 
            Determined by the CLE file.

            Represented as a boolean value, either true or false.
    params: 
            Array containing one object for each argument passed to the function.
            Determined by querying PDGUtils for the list of arguments for the 
            current function name.

            Represented as a JSON array of objects, each with keys type, name, dir,
            and optionally sz.
        type:
                A variable type representing the type of a function's argument.
                Determined by querying DIUtils.getArgTypeName(), which uses
                debug information to check the argument type of the function. 

                Represented by a double quote (") enclosed string that is one of
                IDL's supported C types [double, ffloat, int8, uint8, int16, uint16,
                int32, uint32, int64, uint64] and not a pointer (no *).
        name:
                The argument name of the current argument. Determined by calling
                DIUtils.getArgName() which uses debug information to retrieve 
                argument name.

                Represented by a double quote (") enclosed string conforming to
                c/c++ argument name restrictions.
        dir:
                A string determining if read from or written to by the function
                to decide if it needs to be copied in/out.  Determined by using 
                arg.getAttribute() and checking if in, out, or both are attributes 
                for arg.

                Represented by a double quote (") enclosed string that is one of three values 
                "in", "out", "inout".
        sz:
                A number or word detailing the size of an array argument. Determined by 
                using arg.getAttribute() and checking if count, size, string, or user_check
                are attributes for arg.

                Represented by a bracket enclosed ([]) unsigned integer or a string that is 
                either [string] or [user_check].
    occurs:
            Array containing one object for each callsite of function in "caller".
            Determined by checking callsiteMap, a Map object created at beginning of 
            AccessInfoTracker.cpp that maps every imported function to a Set of the files
            in the "caller" enclave where it is called. This is done by a module pass that
            examines the instructions of every function.

            Represented as a JSON array of objects, each with keys file and line.
        file:
                The path to a file in "caller" enclave containing calls to function.
                Determined by checking value of the current iterator on the Set 
                returned by callsiteMap.

                Represented by a double quote (") enclosed string that conforms to 
                linux path restrictions and refers to a valid c/c++ file on the system.
        lines:
                The line numbers of lines where calls to the function are made in the 
                current file. Determined by querying callsiteLines Map object created
                in the same manner as callsiteMap but recording lines.

                Represented by an array of unsigned integers which must not exceed the
                line count of the current file.


Input:
    A number of directories containing the *.c/h files for each enclave,
    These must be defined in the "enclaves" variable at the top of the Makefile.

Criteria:

    *No functions may have a pointer return type. Any functions with pointer returns must be refactored
        to instead return void and pass a new argument by reference that will act as the return
    *No duplicate functions across domains, except for multithreaded programs where "main" can be duplicated
    *Header files must be created and included for any cross-domain calls
    *Variables should not have any implicit casting to allow for automatic direction and size detection
