# Constraint model for CLE for JOANA SDG based on Java/JVM

## Constraint Model in MiniZinc

Class annotations are currently not used by CLE, but this can change in the future.
Instance and class fields can be annotated by the user with node annotations.
Instance and class methods can be annotated by the user with method annotations.
Constructors can be be annotated by the user with constructor annotations.
Only node annotations can be assigned by the solver to unannotated fields, methods are constructors.



### General Constraints on Output and Setup of Auxiliary Decision Variables

Every class must be assigned to a valid enclave.
All instance methods of a Class must be assigned to the same enclave as the Class.
All instance fields  of a Class must be assigned to the same enclave as the Class.
All static methods of a Class must be assigned to the same enclave as the Class.
All static fields of a Class must be assigned to the same enclave as the Class.

Contained nodes and parameters are assigned the same enclave as their containing
methods.  

Annotations can not assigned to a valid enclave and they must be
assigned to `nullEnclave`.

The level of every node that is not an annotation must match:
 * the level of the label (taint) assigned to the node
 * the level of the enclave the node is assigned to 

Only method entry nodes can be assigned a method annotation label.
Only constructor method entry nodes can be assigned a constructor annotation label.

Furthermore, only the user can bless a method or constructor with a method or constructor annotation 
respectively (that gets be passed to the solver through the input).  

Set up a number of auxiliary decision variables as needed. 

If a node is contained in an unannotated method or constructor then the CLE label taint
assigned to the node must match that of the containing method or constructor. In other
words, since unannotated methods/constructors must be singly tainted, all nodes contained
within the methods/constructors must have the same taint as the method/constructor.


XXX: remaining needs to be worked on for Java/SDG

If a node is contained in an user annotated method, then the CLE label
taint assigned to the node must be allowed by the CLE JSON of the method
annotation in the argument taints, return taints, or code body taints. In other
words, any node contained within a method blessed with a method-annotation
by the user can only contain nodes with taints that are explicitly permitted
(to be coerced) by the method annotation.


### 2.2 Constraints on the Cross-Domain Control Flow

The control flow can never leave an enclave, unless it is done through an
approved cross-domain call, as expressed in the following three constraints.
The only control edges allowed in the cross-domain cut are either call
invocations or returns. For any call invocation edge in the cut, the method
annotation of the method entry being called must have a CDF that allows (with
or without redaction) the level of the label assigned to the callsite.  The
label assigned to the callsite must have a node annotation with a CDF that
allows the data to be shared with the level of the (taint of the) method
entry being called.

Notes: 
  1. No additional constraint is needed for control call return edges; checking
     the corresponding call invocation suffices, however, later on we will check the
     data return edge when checking label coercion.  
  2. The conflict analyzer is working with the annotated unpartitioned
     code and not the fully partitioned code which will includes autogenerated
     code. The actual cut in the partitioned code with autogenerated code to
     handle cross-domain communications will be between the cross-domain send 
     and receive methods that are several steps removed from the cut in the
     `xdedge` (cross domain edge) variable at this stage of analysis. The autogenerated code will 
     apply annotations to cross-domain data annotations that contain GAPS tags,
     and they will have a different label. So we cannot check whether the label 
     of the arguments passed from the caller matches the argument taints allowed by
     the called method, or if the return taints match the value to which the 
     return value is assigned. A downstream verification tool will check this.

### 2.3 Constraints on the Cross-Domain Data Flow

Data can only leave an enclave through parameters or return of valid
cross-domain call invocations, as expressed in the following three constraints. 

Any data dependency edge that is not a data return cannot be in the
cross-domain cut.  For any data return edge in the cut, the taint of the source
node (the returned value in the callee) must have a CDF that allows the data to
be shared with the level of the taint of the destination node (the return site 
in the caller). For any parameter passing edge in the cut, the taint of the source
node (what is passed by the callee) must have a CDF that allows the data to be
shared with the level of the taint of the destination node (the corresponding
actual parameter node of the callee function).


### 2.4 Constraints on Taint Coercion Within Each Enclave

While the constraints on the control dependency and data depdendency that
we discussed governed data sharing at the cross-domain cut, we still need
to perform taint checking to ensure that data annotated with different 
labels inside each enclave are managed correctly and only when the
mixing of the taints is explcitly allowed by the user.

Labels can be cooerced (i.e., nodes of a given SDG edge can be permitted to
have different label assigments) inside an enclave only through user annotated
methods.  To track valid label coercion across a SDG edge `e`, the model uses
an additional auxiliary decision variable called `coerced[e]`.

Any data dependency or parameter edge that is intra-enclave (not in the
cross-domain cut) and with different CLE label taints assigned to the source
and destination nodes must be coerced (through an annotated method).

If the edge is a paremeter in or parameter out edege, then it can be coerced if
and only if the associated method annotation has the taint of the other node
in the argument taints for the corresponding parameter index. In other words,
what is passed in through this parameter has a taint allowed by the method
annotation.

If the edge is a data return edge, then it can be coerced if and only if the
associated method annotation has the taint of the other node in the return
taints.

If the edge is a data dependency edge (and not a return or parameter edge),
then it can be coerced if and only if the associated method annotation allows
the taint of the other node in the argument taints of any parameter.

### To be worked out
 - if a subclass is assigned to an enclave, what about all instance of all its parent classes?
 - what about annotations on methods in interfaces?
 - Do exceptions require a special treatment?
 - Do parameter edges resulting from class fields require special treatment?
 - Is our current formulation too restrictive/impractical?




