

# Constraint model for CLE for JOANA SDG based on Java/JVM
# SDG Graph
## SDG Nodes
A node in the SDG represents an abstraction of IR components used by JOANA. This results in the following node types on the left and are translated to our own abstraction on the right:
    "NORM" : "Inst_Other"
    "PRED" : "Inst_Br"
    "EXPR" : "Inst_Other"
    "SYNC" : "Inst_Other"
    "FOLD" : "Inst_Other"
    "CALL" : "Inst_FunCall"
    "ENTR" : "FunctionEntry"
    "EXIT" : "Inst_Ret"
    "ACTI" : "Param_ActualIn"
    "ACTO" : "Param_ActualOut"
    "FRMI" : "Param_FormalIn"
    "FRMO" : "Param_FormalOut"
## SDG Edges
An edge in the SDG connects two nodes together and has a type. Note that in the SDG model, exceptions are modeled as parameter edges. The following shows the edge types in the SDG on the left and our abstraction on the left: (define set of source and dest node types)
    "CD" : "ControlDep_Other"
    "CE" : "ControlDep_Other"
    "UN" : "ControlDep_Other"
    "CF" : "ControlDep_Other"
    "NF" : "ControlDep_Other"
    "RF" : "ControlDep_CallRet"
    "CC" : "ControlDep_CallInv"
    "CL" : "ControlDep_CallInv"
    "SD" : "ControlDep_Other"
    "JOIN" : "ControlDep_Other"
    "FORK" : "ControlDep_Other"
    "DD" : "DataDepEdge_Other"
    "DH" : "DataDepEdge_Other"
    "DA" : "DataDepEdge_Alias"
    "SU" : "DataDepEdge_Other"
    "SH" : "DataDepEdge_Other"
    "SF" : "DataDepEdge_Other"
    "FD" : "DataDepEdge_Other"
    "FI" : "DataDepEdge_Other"
    "PI" : "Parameter_In"
    "PO" : "Parameter_Out"
    "PS" : "Parameter_Field"
    "PE" : "DataDepEdge_Alias"
    "FORK_IN" : "DataDepEdge_Other"
    "FORK_OUT" : "DataDepEdge_Other"
    "ID" : "DataDepEdge_Other"
    "IW" : "DataDepEdge_Other"


## Constraint Model in MiniZinc

### General Constraints:
* Class annotations are currently not used by CLE, but this can change in the future.

* Instance and class fields can be annotated by the user with node annotations.

* Instance and class methods can be annotated by the user with method annotations.

* Constructors can be annotated by the user with constructor annotations.

* Only node annotations can be assigned by the solver to unannotated fields, methods or constructors.

* Method or constructor annotations cannot be assigned by the solver (these can only be assigned by the user). 


### General Constraints on Output and Setup of Auxiliary Decision Variables

Every class must be assigned to at least one valid enclave.
** Each class containing one or more annotated elements (constructor, method, or field) must be assigned to exactly one enclave. 
** Each class containing no annotated elements must be assigned to at least one enclave and at most every enclave.

Across all accesses/invocations of an unannotated element, it may touch at most one label at each level.

All elements (constructor, method, or field) of a class instance must be assigned the same enclave as the instance itself.

This entails separate constraints for constructors, instance methods, instance fields, static methods and static fields.

Contained nodes and parameters are assigned the same enclave(s) as their containing
methods.  

Annotations can not be assigned to a valid enclave and they must be
assigned to `nullEnclave`.

Each (node,level) pair is assigned at most one valid enclave at that level.
Each (node,level) pair is assigned at most one valid label with that level.

Only method entry nodes can be assigned a method annotation label.
Only constructor entry nodes can be assigned a constructor annotation label.

### 2.2 Constraints on the Cross-Domain Control Flow

The control flow can never leave an enclave, unless it is done through an
approved cross-domain call, as expressed in the following constraints.

1) The only control edges allowed in the cross-domain cut are either call
invocations or returns. 

2) For any call invocation edge in the cut, the method annotation of the method entry being called must have a CDF that allows (with or without redaction) the level of the label assigned to the callsite (caller).  

<!-- 3) The label assigned to the callsite (caller) must have a node annotation with a CDF that
allows the data to be shared with the level of the (taint of the) method entry being called. -->


<!-- ### Notes
  1. No additional constraint is needed for control call return edges; checking
     the corresponding call invocation suffices, however, later on we will check the
     data return edge when checking label coercion. 

  2. The conflict analyzer is working with the annotated unpartitioned
     code and not the fully partitioned code which will includes autogenerated
     code. The actual cut in the partitioned code with autogenerated code to
     handle cross-domain communications will be between the cross-domain send 
     and receive methods that are several steps removed from the cut in the
     `xdedge` (cross domain edge) variable at this stage of analysis. The autogenerated code will 
     apply annotations to cross-domain data annotations that contain GAPS tags,
     and they will have a different label. So we cannot check whether the label 
     of the arguments passed from the caller matches the argument taints allowed by
     the called method, or if the return taints match the value to which the 
     return value is assigned. A downstream verification tool will check this. -->


### 2.3 Constraints on the Cross-Domain Data Flow

Data can only leave an enclave through parameters or return of valid
cross-domain call invocations, as expressed in the following three constraints. 

1) Any data dependency edge that is not a parameter or data return cannot be in the
cross-domain cut.  

2) For any data return edge in the cut, the taint of the source
node (the returned value in the callee) must have a CDF that allows the data to
be shared with the level of the taint of the destination node (the return site 
in the caller). 

3) For any parameter passing edge in the cut, the taint of the source
node must have a CDF that allows the data to be shared with the level of the taint of the destination node. This applies to the input parameters going from caller to callee and output parameters going from callee back to the caller.


### 2.4 Constraints on Taint Coercion Within Each Enclave

Each node in an unannotated method or constructor must have the same taint as the containing unannotated method or constructor itself.

For each parameter or data dependency (including returns) edges with at least one end point in an unannotated method or constructor, both end points must have the same taint.

Each node in an annotated method or constructor must have a taint that is allowed by the argument taints (argtaints), code taints (codtaints), or the return taints (rettaints) of the corresponding method/constructor annotation.

For each parameter-in or parameter-out edge connected to an argument of an annotated method or constructor, the taint of the remote (caller side) endpoint must be allowed by the argument taints (argtaints) for that argument in the annotation applied to the method or constructor.

For each data return edge of an annotated method or constructor, the taint of remote (caller side) endpoint must be allowed by the return taints (rettaints) of the annotation applied to the method or constructor.

For each data dependency edge (that is not a return or parameter edge) of an annotated method or constructor, the taint of both endpoints must be allowed by either the argument taints (argtaints), code taints (codtaints), or return taints (rettaints) of the annotation applied to the method or constructor.



Note: Need additional constraints for class and static components

All of the above constraints may need to be revisited due to dealing with per level for unannotated functions



