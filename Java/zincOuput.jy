from json                                   import loads,dump
from argparse                               import ArgumentParser
from pprint                                 import PrettyPrinter

from java.lang                              import Class
from java.lang                              import System
from java.lang                              import Process,ProcessBuilder
from java.io                                import FileOutputStream
from com.ibm.wala.util                      import NullProgressMonitor
from edu.kit.joana.api.sdg                  import SDGConfig
from edu.kit.joana.api.sdg                  import SDGProgram
from edu.kit.joana.ifc.sdg.graph            import SDGSerializer
from edu.kit.joana.ifc.sdg.mhpoptimization  import MHPType
from edu.kit.joana.ifc.sdg.util             import JavaMethodSignature
from edu.kit.joana.util                     import Stubs
from edu.kit.joana.wala.core.SDGBuilder     import PointsToPrecision
from edu.kit.joana.wala.core.SDGBuilder     import ExceptionAnalysis
from edu.kit.joana.ifc.sdg.io.dot           import JoanaGraph2Dot
from java.util.jar                          import JarFile;
from collections import defaultdict
from collections import OrderedDict

def writePDG(sdg, pdgFile): 
  SDGSerializer.toPDGFormat(sdg, FileOutputStream(pdgFile))

def writeDOT(sdg, dotFile): 
  JoanaGraph2Dot.writeDotToOutputStream(sdg, FileOutputStream(dotFile))

def writeCLE(cles, jsonFile): 
  with open(args.jsonfile,'w') as of: dump(cles, of, indent=2, sort_keys=True)

def getClasses(cp):
  for cnm in [x.getName().replace('/','.').replace('.class','') for x in JarFile(cp).entries() if x.getName().endswith('.class')]:
    try:                   yield cnm,Class.forName(cnm)
    except Exception as e: print('Error getting class ' + cnm + ':' + str(e))

def collectCLE(cp):
  cles = []
  labels = []
  for cnm,cls in getClasses(cp):
    if cls.isAnnotation():
      for y in [x for x in cls.getDeclaredAnnotations() if x.annotationType().getName().endswith('Cledef')]: 
        try:
            # don't add duplicate labels
            if cnm in labels:
              continue                   
            cles.append(dict(clelabel=cnm,clejson=loads(y.clejson()))) 
            labels.append(cnm)
        except Exception as e: print('CLE JSON failed for ' + y.toString())
  return cles

def dumpCLE(cp):
  cles = {}
  for cnm,cls in getClasses(cp):
    if cls.isAnnotation():
      for y in [x for x in cls.getDeclaredAnnotations() if x.annotationType().getName().endswith('Cledef')]: 
        try:                   
            # Throw error if label already exists
            if cnm in cles.keys():
              raise
            else:
              cles[cnm] = loads(y.clejson())
              

        except Exception as e: print('CLE JSON failed for ' + y.toString())
  return cles

def cleAnnotationsForNode(node, prog, clabels):
  return [q for q in [str(x.getType().getName()).lstrip('L').replace('/','.') for x in prog.getMiscAnnotations(node)] if q in clabels]

def makeSDG(cp, em):
  classPath   = cp
  entryMethod = JavaMethodSignature.mainMethodOfClass(em)
  config      = SDGConfig(classPath, entryMethod.toBCString(), Stubs.JRE_15)
  config.setComputeInterferences(True)
  config.setMhpType(MHPType.PRECISE)
  config.setPointsToPrecision(PointsToPrecision.INSTANCE_BASED)
  config.setExceptionAnalysis(ExceptionAnalysis.INTERPROC)
  program = SDGProgram.createSDGProgram(config, System.out, NullProgressMonitor())
  return program


def compute_zinc(cleJson, maxArgIdx):
    
    functions2back = []
    functionJsons = []
    nonFunctionJsons = []
    for entry in range(len(cleJson)):
        if "clejson" in cleJson[entry].keys() and "cdf" in cleJson[entry]["clejson"].keys() and "codtaints" in cleJson[entry]["clejson"]["cdf"][0]: 
            functionJsons.append(cleJson[entry])
        else:
            nonFunctionJsons.append(cleJson[entry])

    for entry in nonFunctionJsons:
        functions2back.append(entry) 
    for entry in functionJsons:
        functions2back.append(entry) 
    
    cleJson = functions2back
    
    hasCDF = []
    hasArgTaints = []
    listOfLevels = []

    # one_way_map = {}
    # print(one_way)
    # for line in one_way.splitlines():
    #     print(line)
    #     one_way_map[line.split()[0]] =  line.split()[1]

    noneCount = 0
    enums = defaultdict(lambda: [])
    arrays = defaultdict(lambda: [])
    enums["cleLabel"].append("nullCleLabel")
    arrays['hasLabelLevel'].append("nullLevel") 
    arrays['isFunctionAnnotation'].append("false") 
    enums['cdf'].append("nullCdf")
    hasCDF.append([])
    hasCDF[-1].append("None" + "_cdf_" + str(noneCount))
    
    enums['remotelevel'].append("None" + "_remotelevel_" + str(noneCount))
    enums['direction'].append("None" + "_direction_" + str(noneCount))
    enums['operation'].append("None" + "_operation_" + str(noneCount))
    arrays["fromCleLabel"].append("nullCleLabel")
    arrays["hasRemotelevel"].append("nullLevel")
    arrays["hasDirection"].append("nullDirection")
    arrays["hasGuardOperation"].append("nullGuardOperation")
    arrays["isOneway"].append("false")
    arrays["hasARCtaints"] = []
    noneCount +=1
    
    maxCDFIdx = 0
    # data = pdg_instance.splitlines()
    # for d in data:
    #     if 'MaxFuncParms' in d:
    #         maxArgIdx = int(d.split()[-1][:-1])
    #         break
    # print(maxArgIdx)

    # fun2ArgCount = {}
    # data = function_args.splitlines()
    # for d in data:
    #     fun2ArgCount[d.split()[0]] = int(d.split()[1])

    listOfLevels.append("nullLevel")
    for entry in cleJson:
        if "clejson" in entry.keys() and "level" in entry["clejson"].keys():
            listOfLevels.append(entry["clejson"]['level'])
        else:
            listOfLevels.append("nullLevel")
    
    listOfLevels = set(listOfLevels)
    listOfLevels = list(listOfLevels)
    listOfLevels.sort()
    listOfLevels.remove("nullLevel")
    listOfLevels.insert(0,"nullLevel")
    nullLevel = ["nullCdf" for x in range(len(listOfLevels))]
    arrays["cdfForRemoteLevel"].append(nullLevel)
    print(listOfLevels)

    #Need to add this fix to C implementation too
    labelList = []
    for entry in cleJson:
      labelList.append(entry["clelabel"].split(".")[-1])

    for entry in cleJson:
        CDF_flag = False
        print("ENTRY")
        print(entry)
        

        enums["cleLabel"].append(entry["clelabel"].split(".")[-1])
        if "clejson" in entry.keys() and "level" in entry["clejson"].keys():
            arrays['hasLabelLevel'].append(entry["clejson"]['level'])
        else:
            arrays['hasLabelLevel'].append("nullLevel")
        
        # only checks if the first cdf has function taints, assumes they all do
        if "clejson" in entry.keys() and "cdf" in entry["clejson"].keys() and "codtaints" in entry["clejson"]["cdf"][0]: 
            arrays['isFunctionAnnotation'].append("true")
        else:
            arrays['isFunctionAnnotation'].append("false")

        CDFforEntry = [] 
        #assumes only one cdf in the label has a certaint remote level
        for j in listOfLevels:
            found = 0
            if "clejson" in entry.keys() and "cdf" in entry["clejson"].keys():
                cdfIdx = 0
                for cdf in entry["clejson"]["cdf"]:
                    cdfStr = entry["clelabel"].split(".")[-1] + "_cdf_" + str(cdfIdx)
                    if "remotelevel" in cdf.keys():
                        if cdf["remotelevel"] == j:
                            CDFforEntry.append(cdfStr)
                            temp = cdf["remotelevel"]
                            # print("Found remote level: {j}")
                            found = 1
                    cdfIdx+=1
            if found == 0:
                CDFforEntry.append("nullCdf")
        arrays["cdfForRemoteLevel"].append(CDFforEntry)

        if "clejson" in entry.keys() and "cdf" in entry["clejson"].keys():
            cdfIdx = 0
            for cdf in entry["clejson"]["cdf"]:
                cdfStr = entry["clelabel"].split(".")[-1] + "_cdf_" + str(cdfIdx)
                enums["cdf"].append(cdfStr)
                arrays['fromCleLabel'].append(entry["clelabel"].split(".")[-1])

                if "remotelevel" in cdf.keys():
                    arrays['hasRemotelevel'].append(cdf["remotelevel"])
                else:
                    arrays['hasRemotelevel'].append("nullLevel")

                if "direction" in cdf.keys():
                    arrays['hasDirection'].append(cdf["direction"])
                else:
                    arrays['hasDirection'].append("nullDirection")

                if "guarddirective" in cdf.keys():
                    arrays['hasGuardOperation'].append(cdf["guarddirective"]["operation"])
                else:
                    arrays['hasGuardOperation'].append("nullGuardOperation")

                if "oneway" in cdf.keys():
                    if entry["clelabel"].split(".")[-1] in one_way_map.keys() and one_way_map[entry["clelabel"].split(".")[-1]] == "false":
                        print("Error, oneway function has uses!")
                        raise
                    arrays['isOneway'].append(cdf["oneway"])
                else:
                    arrays['isOneway'].append("false")

                if "rettaints" in cdf.keys():
                    for label in cdf['rettaints']:
                        splLbl = label.split(".")[-1]
                        if splLbl not in labelList:
                            enums["cleLabel"].append(label.split(".")[-1])
                            arrays['hasLabelLevel'].append("nullLevel") 
                            arrays['isFunctionAnnotation'].append("false")
                            arrays["cdfForRemoteLevel"].append(nullLevel)
                if "codtaints" in cdf.keys():
                    for label in cdf['codtaints']:
                        splLbl = label.split(".")[-1]
                        print("Checking Code Taints" + str(splLbl))
                        print(enums["cleLabel"])
                        if splLbl not in labelList:
                            enums["cleLabel"].append(label.split(".")[-1])
                            arrays['hasLabelLevel'].append("nullLevel") 
                            arrays['isFunctionAnnotation'].append("false")
                            arrays["cdfForRemoteLevel"].append(nullLevel)
                if "argtaints" in cdf.keys():
                    for param in cdf['argtaints']:
                        for label in param:
                            splLbl = label.split(".")[-1]
                            if splLbl not in labelList:
                                enums["cleLabel"].append(label.split(".")[-1])
                                arrays['hasLabelLevel'].append("nullLevel") 
                                arrays['isFunctionAnnotation'].append("false")
                                arrays["cdfForRemoteLevel"].append(nullLevel)
                cdfIdx+=1
   
    
    for level in listOfLevels:
        if level == "nullLevel":
            continue
        newLabelStr = level+"DFLT"
        enums["cleLabel"].append(newLabelStr)
        arrays['hasLabelLevel'].append(level) 
        arrays['isFunctionAnnotation'].append("false")
        arrays["cdfForRemoteLevel"].append(nullLevel)

    anyFunctionCdfs = False
    for i in arrays['isFunctionAnnotation']:
        if i == "true":
            anyFunctionCdfs = True
            break
    
    if not anyFunctionCdfs:
        enums["cleLabel"].append("EmptyFunction")
        arrays['hasLabelLevel'].append("nullLevel") 
        arrays['isFunctionAnnotation'].append("true")
        cdfStr = "EmptyFunction_cdf_0"
        enums["cdf"].append(cdfStr)
        arrays['fromCleLabel'].append("EmptyFunction")
        arrays['hasRemotelevel'].append("nullLevel")
        arrays['hasDirection'].append("nullDirection")
        arrays['hasGuardOperation'].append("nullGuardOperation")
        arrays['isOneway'].append("false")

        emptyFunLevel = ["nullCdf" for x in range(len(listOfLevels))]
        emptyFunLevel[0] = "EmptyFunction_cdf_0"
        arrays["cdfForRemoteLevel"].append(emptyFunLevel)

        entry = {}
        entry["clelabel"] = "EmptyFunction"
        entry["clejson"] = {}
        entry["clejson"]["level"] = "nullLevel"
        entry["clejson"]["cdf"] = []
        cdf = {}
        cdf["remotelevel"] = "nullLevel"
        cdf["argtaints"] = []
        cdf["codtaints"] = []
        cdf["rettaints"] = []
        entry["clejson"]["cdf"].append(cdf)
        cleJson.append(entry)


    
    for entry in cleJson:
        print("ENTRY")
        print(entry)
        
        #if codtaints is defined, all taints need to be defined
        if "clejson" in entry.keys() and "cdf" in entry["clejson"].keys():
            if "codtaints" in entry["clejson"]["cdf"][0] or "rettaints" in entry["clejson"]["cdf"][0] or "argtaints" in entry["clejson"]["cdf"][0]:
                if not("codtaints" in entry["clejson"]["cdf"][0] and "rettaints" in entry["clejson"]["cdf"][0] and "argtaints" in entry["clejson"]["cdf"][0]):
                    print("Missing 1 or more function taints!")
                    raise

        # if entry["clelabel"] != "EmptyFunction" and entry["clelabel"] in fun2ArgCount.keys():
        #     if "clejson" in entry.keys() and "cdf" in entry["clejson"].keys():
        #         if not("codtaints" in entry["clejson"]["cdf"][0] and "rettaints" in entry["clejson"]["cdf"][0] and "argtaints" in entry["clejson"]["cdf"][0]):
        #             print("Function Annotation missing function taints!")
        #             raise
        #     else:
        #         print("Function Annotation missing CDF!")
        #         raise

        if "clejson" in entry.keys() and "cdf" in entry["clejson"].keys() and "codtaints" in entry["clejson"]["cdf"][0]:
            ARCTaint = ["false" if label != entry["clelabel"] else "true" for label in enums["cleLabel"] ]
            for cdf in entry["clejson"]["cdf"]:
                # code taints
                taintEntry = []  
                for label in enums["cleLabel"]:
                    found = 0
                    for labelTaint in cdf["codtaints"]:
                        if label == labelTaint:
                            taintEntry.append("true")
                            found = 1
                    if found == 0:
                        taintEntry.append("false")
                arrays["hasCodtaints"].append(taintEntry)
                ARCTaint = [str(a=='true' or b=='true').lower()  for a, b in zip(ARCTaint, taintEntry)]
                
                # ret Taints
                taintEntry = []  
                for label in enums["cleLabel"]:
                    found = 0
                    for labelTaint in cdf["rettaints"]:
                        if label == labelTaint:
                            taintEntry.append("true")
                            found = 1
                    if found == 0:
                        taintEntry.append("false")
                arrays["hasRettaints"].append(taintEntry)
                ARCTaint = [str(a=='true' or b=='true').lower() for a, b in zip(ARCTaint, taintEntry)]
                hasArgFlag = 1
                # Arg Taints
                taintEntry = []
                print(cdf["argtaints"])
                paramCount = 0
                for param in cdf["argtaints"]:
                    if len(param) == 0:
                        hasArgFlag = 0
                        break
                    paramEntry = []  
                    for label in enums["cleLabel"]:
                        found = 0
                        for labelTaint in param:
                            if label == labelTaint:
                                paramEntry.append("true")
                                found = 1
                            else:
                                paramEntry.append("false")
                    ARCTaint = [str(a=='true' or b=='true').lower()  for a, b in zip(ARCTaint, paramEntry)]
                    taintEntry.append(paramEntry)
                    paramCount +=1
                

                # if entry["clelabel"] in fun2ArgCount.keys() and entry["clelabel"] != "EmptyFunction" and fun2ArgCount[entry["clelabel"]] < paramCount and hasArgFlag:
                #     print("ERROR! Function annotation argument mismatch!")
                #     raise

                while paramCount < maxArgIdx:
                    paramEntry = []  
                    for label in enums["cleLabel"]:
                        paramEntry.append("false")
                    ARCTaint = [str(a=='true' or b=='true').lower()  for a, b in zip(ARCTaint, paramEntry)]
                    taintEntry.append(paramEntry)
                    paramCount +=1
                
                arrays["hasArgtaints"].append(taintEntry)
                arrays["hasARCtaints"].append(ARCTaint)

    # if len(enums["cleLabel"]) > len(set(enums["cleLabel"])):
    #     print("Error! Duplicate CLE Lables detected.")
    #     raise

    maxCodTaint = 0
    # maxArgIdx = 0
    maxNumArgsTaints = 0
    maxRetTaint = 0

    # for taints in arrays["hasargtaints"]: 
    #     if len(taints) > maxArgIdx:
    #         maxArgIdx = len(taints)

    for taints in arrays["hasargtaints"]: 
        for args in taints:
            if len(args) > maxNumArgsTaints:
                maxNumArgsTaints = len(args)

    for taints in arrays["hasrettaints"]: 
        if len(taints) > maxRetTaint:
            maxRetTaint = len(taints)

    for taints in arrays["hascodtaints"]: 
        if len(taints) > maxCodTaint:
            maxCodTaint = len(taints)

    enclave_instance = ""
    Levels = "Level = {"
    Enclave = "Enclave = {"
    hasEnclaveLevel = "hasEnclaveLevel = ["
    for level in listOfLevels:
        Levels += level + ","
        if level == "nullLevel":
            Enclave +=  "nullEnclave, "
        else:
            Enclave += level + "_E,"
        hasEnclaveLevel += level + ","
    Levels = Levels[:-1]
    Enclave = Enclave[:-1]
    hasEnclaveLevel = hasEnclaveLevel[:-1]
    Levels += "};\n"
    Enclave += "};\n"
    hasEnclaveLevel += "];\n"

    enclave_instance += Levels 
    enclave_instance += Enclave
    enclave_instance += hasEnclaveLevel


    cle_instance = ""

    cle_instance += "cleLabel = {"
    first = True
    for j in enums["cleLabel"]:
        if first:
            first = False
            cle_instance += j
        else:
             cle_instance = cle_instance + ", " + j
    cle_instance += ("}; \n")

    cle_instance += ("hasLabelLevel = [")
    first = True
    for j in arrays["hasLabelLevel"]:
        if first:
            first = False
            cle_instance +=  j
        else:
            cle_instance = cle_instance + ", " + j
    cle_instance += ("]; \n")
    
    cle_instance += ("isFunctionAnnotation = [")
    first = True
    for j in arrays["isFunctionAnnotation"]:
        if first:
            first = False
            cle_instance = cle_instance + j
        else:
            cle_instance = cle_instance + ", " + j
    cle_instance += ("]; \n")

    cle_instance += "cdf = {"
    first = True
    for j in enums["cdf"]:
        if first:
            first = False
            cle_instance = cle_instance + j
        else:
            cle_instance = cle_instance + ", " + j
    cle_instance += ("}; \n")

    cle_instance += ("fromCleLabel = [")
    first = True
    for j in arrays["fromCleLabel"]:
        if first:
            first = False
            cle_instance = cle_instance  + j
        else:
            cle_instance = cle_instance + ", " + j
    cle_instance += ("]; \n")

    cle_instance += ("hasRemotelevel = [")
    first = True
    for j in arrays["hasRemotelevel"]:
        if first:
            first = False
            cle_instance = cle_instance + j
        else:
            cle_instance = cle_instance + ", " + j
    cle_instance += ("]; \n")

    cle_instance += ("hasDirection = [")
    first = True
    for j in arrays["hasDirection"]:
        if first:
            first = False
            cle_instance = cle_instance + j
        else:
            cle_instance = cle_instance + ", " + j
    cle_instance += ("]; \n")

    cle_instance += ("hasGuardOperation = [")
    first = True
    for j in arrays["hasGuardOperation"]:
        if first:
            first = False
            cle_instance = cle_instance + j
        else:
            cle_instance = cle_instance + ", " + j
    cle_instance += ("]; \n")

    cle_instance += ("isOneway = [")
    first = True
    for j in arrays["isOneway"]:
        if first:
            first = False
            cle_instance = cle_instance + j
        else:
            cle_instance = cle_instance + ", " + j
    cle_instance += ("]; \n")

    cle_instance += ("cdfForRemoteLevel = [|\n ")
    for row in arrays["cdfForRemoteLevel"]:
        print(row)
        first = True
        for j in row:
            if first:
                first = False
                cle_instance = cle_instance + j
            else:
                cle_instance = cle_instance + ", " + j
        cle_instance += ("\n|")
    cle_instance += ("]; \n")

    numFunctionCDFS = len(arrays["hasRettaints"])
    # print("Num Function CDFs: {numFunctionCDFS}")
    numCleLabels = len(enums["cleLabel"])
    # print("Num CLE Labels: {numCleLabels}")


    cle_instance += ("hasRettaints = array2d(functionCdf, cleLabel, [\n ")
    first = True
    for row in arrays["hasRettaints"]:
        print(row)
        for j in row:
            if j == "true":
                j = "true "
            if first:
                first = False
                cle_instance += j
            else:
                 cle_instance = cle_instance + ", " + j
        cle_instance += ("\n")
    cle_instance += (" ]); \n")
    numElts = 0
    for i in arrays["hasRettaints"]:
        for j in i:
            numElts+=1
    if numFunctionCDFS * numCleLabels != numElts:
        print("hasRettaints has incorrect dimensions")


    cle_instance += ("hasCodtaints = array2d(functionCdf, cleLabel, [\n ")
    first = True
    for row in arrays["hasCodtaints"]:
        print(row)
        for j in row:
            if j == "true":
                j = "true "
            if first:
                first = False
                cle_instance += j
            else:
                 cle_instance = cle_instance + ", " + j
        cle_instance += ("\n")
    cle_instance += (" ]); \n")
    numElts = 0
    for i in arrays["hasCodtaints"]:
        for j in i:
            numElts+=1
    if numFunctionCDFS * numCleLabels != numElts:
        print("hasCodtaints has incorrect dimensions")

    cle_instance += ("hasArgtaints = array3d(functionCdf, parmIdx, cleLabel, [\n ")
    first = True
    for row in arrays["hasArgtaints"]:
        print(row)
        argCount = 0
        for nested in row:
            for j in nested:
                if j == "true":
                    j = "true "
                if first:
                    first = False
                    cle_instance += j
                else:
                     cle_instance = cle_instance + ", " + j

                if argCount % maxArgIdx == maxArgIdx -1:
                    cle_instance += ("\t\t")
                argCount+=1
        cle_instance += ("\n")
    cle_instance += (" ]); \n")
    numElts = 0
    for i in arrays["hasArgtaints"]:
        for j in i:
            for k in j:
                numElts+=1
    if numFunctionCDFS * maxArgIdx * numCleLabels != numElts:
        print("hasArgtaints has incorrect dimensions")

    cle_instance += ("hasARCtaints = array2d(functionCdf, cleLabel, [\n ")
    first = True
    for row in arrays["hasARCtaints"]:
        print(row)
        for j in row:
            if j == "true":
                j = "true "
            if first:
                first = False
                cle_instance += j
            else:
                 cle_instance = cle_instance + ", " + j
        cle_instance += ("\n")
    cle_instance += (" ]); \n")

    numElts = 0
    for i in arrays["hasARCtaints"]:
        for j in i:
            numElts+=1
    if numFunctionCDFS * numCleLabels != numElts:
        print("hasARCtaints has incorrect dimensions")

    print(enums)
    print(arrays)

    return (cle_instance, enclave_instance)   

def get_args():
  p = ArgumentParser(description='CLOSURE System Dependence Graph Builder for Java')
  p.add_argument('-e', '--entrymethod', required=True, type=str, help='Entry Method')
  p.add_argument('-b', '--bname', required=True, type=str, help='Base name for classes of interest ')
  p.add_argument('-c', '--clpath', required=True, type=str, help='Jar file for program to be analyzed')
  p.add_argument('-p', '--pdg', help='Dump Program Dependence Graph in native format',
                 default=False, action='store_true') 
  p.add_argument('-P', '--pdgfile', help='PDG filename', 
                 required=False, type=str, default='yourSDGFile.pdg')
  p.add_argument('-d', '--dot',help='Dump Program Dependence Graph in Dot format',
                 default=False, action='store_true') 
  p.add_argument('-D', '--dotfile', help='DOT filename',
                 required=False, type=str, default='yourSDGFile.dot')
  p.add_argument('-j', '--json',help='Dump CLE JSON',
                 default=False, action='store_true') 
  p.add_argument('-J', '--jsonfile', help='CLE JSON output filename', 
                 required=False, type=str, default='yourSDGFile.clemap.json')
  return p.parse_args()


if __name__ == '__main__':
  args   = get_args()
  zincFile = open("./pdg_instance.mzn", "w")
  print('Options selected:')
  for x in sorted(vars(args).items()): print('  %s: %s' % x)
  bname = args.bname
  prog = makeSDG(args.clpath, args.entrymethod)
  sdg  = prog.getSDG()
  cles = collectCLE(args.clpath)
  if args.pdg:  writePDG(sdg, args.pdgfile)
  if args.dot:  writeDOT(sdg, args.dotfile)
  if args.json: writeCLE(cles, args.jsonfile)
  print('SDG Done\n')

  clabels = list([q['clelabel'] for q in cles])
  nodes   = {}
  edges   = {}
  anns    = {}

  nodesZinc = OrderedDict()
  edgesZinc = OrderedDict()

  nodesZinc["Inst_FunCall"] = []
  nodesZinc["Inst_Ret"] = []
  nodesZinc["Inst_Br"] = []
  nodesZinc["Inst_Other"] = []
  nodesZinc["FunctionEntry"] = []
  nodesZinc["Param_FormalIn"] = []
  nodesZinc["Param_FormalOut"] = []
  nodesZinc["Param_ActualIn"] = []
  nodesZinc["Param_ActualOut"] = []

  edgesZinc["ControlDep_CallInv"] = []
  edgesZinc["ControlDep_CallRet"] = []
  edgesZinc["ControlDep_Other"] = []
  edgesZinc["DataDepEdge_Alias"] = []
  edgesZinc["DataDepEdge_Other"] = []
  edgesZinc["Parameter_In"] = []
  edgesZinc["Parameter_Out"] = []
  edgesZinc["Parameter_Field"] = []

  nodeConversion = {
      "NORM" : "Inst_Other",
      "PRED" : "Inst_Br",
      "EXPR" : "Inst_Other",
      "SYNC" : "Inst_Other",
      "FOLD" : "Inst_Other",
      "CALL" : "Inst_FunCall",
      "ENTR" : "FunctionEntry",
      "EXIT" : "Inst_Ret",
      "ACTI" : "Param_ActualIn",
      "ACTO" : "Param_ActualOut",
      "FRMI" : "Param_FormalIn",
      "FRMO" : "Param_FormalOut",
  }

  edgeConversion = {
      "CD" : "ControlDep_Other",
      "CE" : "ControlDep_Other",
      "UN" : "ControlDep_Other",
      "CF" : "ControlDep_Other",
      "NF" : "ControlDep_Other",
      "RF" : "ControlDep_CallRet",
      "CC" : "ControlDep_CallInv",
      "CL" : "ControlDep_CallInv",
      "SD" : "ControlDep_Other",
      "JOIN" : "ControlDep_Other",
      "FORK" : "ControlDep_Other",
      "DD" : "DataDepEdge_Other",
      "DH" : "DataDepEdge_Other",
      "DA" : "DataDepEdge_Alias",
      "SU" : "DataDepEdge_Other",
      "SH" : "DataDepEdge_Other",
      "SF" : "DataDepEdge_Other",
      "FD" : "DataDepEdge_Other",
      "FI" : "DataDepEdge_Other",
      "PI" : "Parameter_In",
      "PO" : "Parameter_Out",
      "PS" : "Parameter_Field",
      "PE" : "DataDepEdge_Alias",
      "FORK_IN" : "DataDepEdge_Other",
      "FORK_OUT" : "DataDepEdge_Other",
      "ID" : "DataDepEdge_Other",
      "IW" : "DataDepEdge_Other",
  }

  funcID2Entry = {}
  Entry2funcID = {}
  funcID2EntryVal = {}
 
  for y in sorted(set(sdg.vertexSet()),key=lambda x: x.getId()):
    kind  = str(y.getKind().toString())
    nid   = str(y.getId())
    label = str(y.getLabel())
    oper  = str(y.getOperation())

    nkind = kind + '_' + oper
    if not nkind in nodes: nodes[nkind] = []
    nodes[nkind].append((nid,label))
    hasFunction = y.getBytecodeMethod()

    if not nodeConversion[kind] in nodesZinc: nodesZinc[nodeConversion[kind]] = []
    nodesZinc[nodeConversion[kind]].append((nid,oper, y))

    myann = cleAnnotationsForNode(y, prog, clabels)
    if len(myann) > 0: anns[nid] = myann 

    for e in sdg.outgoingEdgesOf(y): 
      ekind = str(e.getKind().toString())
      if not ekind in edges: edges[ekind] = []
      edges[ekind].append((nid,str(e.getTarget().getId())))

      # We do not care about helper edges "HE"
      if ekind == "HE":
          continue
      
      if ekind == "PO" and kind == "EXIT":
          if not "DataDepEdge_Ret" in edgesZinc : edgesZinc["DataDepEdge_Ret"] = []
          edgesZinc["DataDepEdge_Ret"].append((nid,str(e.getTarget().getId())))
      else:
            if not edgeConversion[ekind] in edgesZinc : edgesZinc[edgeConversion[ekind]] = []
            edgesZinc[edgeConversion[ekind]].append((nid,str(e.getTarget().getId())))
            

    
    if kind == "ENTR":
      funcID2Entry[y.getProc()] = int(nid)
      funcID2EntryVal[y.getProc()] = y
      Entry2funcID[int(nid)] = y.getProc()
      numArgs = len(sdg.incomingEdgesOf(y))

  idx = 1
  nodeIdx = OrderedDict()
  edgeIdx = OrderedDict()
  nodeID2Idx = OrderedDict()
  idx2nodeID = OrderedDict()

  paramNodes = []

  nodeIdx["Inst"] = []
  nodeIdx["Param"] = []
  nodeIdx["PDGNode"] = []
  for kind in nodesZinc:
    for node in nodesZinc[kind]:
      if kind in nodeIdx:
        nodeIdx[kind].append(idx)
      else:
        nodeIdx[kind] = [idx]
      if "Inst" in kind:
          nodeIdx["Inst"].append(idx)
      if "Param" in kind:
          nodeIdx["Param"].append(idx)
          paramNodes.append(node[2])
      nodeIdx["PDGNode"].append(idx)
      nodeID2Idx[int(node[0])] = idx
      idx2nodeID[idx] =  int(node[0])
      idx+=1

  hasSource = []
  hasDest = []
  edgeIdx["ControlDep"] = []
  edgeIdx["DataDepEdge"] = []
  edgeIdx["Parameter"] = []
  edgeIdx["PDGEdge"] = []

  dbgFileEdge = open("./dbg_edge.csv", "w")
  idx = 1
  for kind in edgesZinc:
    for edge in edgesZinc[kind]:
      if kind in edgeIdx:
        edgeIdx[kind].append(idx)
      else:
        edgeIdx[kind] = [idx]
      if "ControlDep" in kind:
          edgeIdx["ControlDep"].append(idx)
      if "DataDepEdge" in kind:
          edgeIdx["DataDepEdge"].append(idx)
      if "Parameter" in kind:
          edgeIdx["Parameter"].append(idx)
      edgeIdx["PDGEdge"].append(idx)
      hasSource.append(nodeID2Idx[int(edge[0])])
      hasDest.append(nodeID2Idx[int(edge[1])])

      dbgStr = str(idx) + ", " + str(kind) + ", " + str(nodeID2Idx[int(edge[0])]) + ", " + str(nodeID2Idx[int(edge[1])]) + "\n"
      dbgFileEdge.write(dbgStr)
      idx+=1
  
  
  dbgFileNode = open("./dbg_node.csv", "w")
  for kind in nodeIdx:
    zincFile.write(kind + "_start = " + str(nodeIdx[kind][0]) + "; \n" )
    zincFile.write(kind + "_end = " + str(nodeIdx[kind][-1]) + "; \n" )

  for kind in edgeIdx:
    zincFile.write(kind + "_start = " + str(edgeIdx[kind][0]) + "; \n" )
    zincFile.write(kind + "_end = " + str(edgeIdx[kind][-1]) + "; \n" )

  outString = ""
  outString += "hasFunction = [ \n"
  for y in sorted(set(sdg.vertexSet()),key=lambda x: x.getId()):
    pid   = y.getProc()
    # import pdb; pdb.set_trace()
    print("Function ID " + str(funcID2Entry[pid]))
    outString = outString + str(nodeID2Idx[int(funcID2Entry[pid])]) + ", " 
  outString = outString[:-2] + "];\n"

  classNames = []
  outString += "hasClass = [ \n"
  for y in sorted(set(sdg.vertexSet()),key=lambda x: x.getId()):
    pid   = y.getProc()
    nid   = str(y.getId())
    kind  = str(y.getKind().toString())
    label = str(y.getLabel())

    
    # import pdb; pdb.set_trace()
    className = str(funcID2EntryVal[pid].getBytecodeName()).split(".")
    # find first index containing a parenthesis, this indicates end of class name
    iterations = 0
    for token in className:
        if "(" in token  or ")" in token:
            break
        iterations +=1

    nameCheck = ".".join(className[:iterations])
    className = "__".join(className[:iterations])
    print("Class Name " + str(className))
    if not bname in nameCheck:
        className = "sharedClass"
    classNames.append(className)
    outString = outString + className + ", " 


    dbgStr = str(nodeID2Idx[int(nid)]) + ", " + nid + ", " + nodeConversion[kind] + ", " + label + ", " + str(nodeID2Idx[int(funcID2Entry[pid])]) + ", " + y.getSource() + ", " + str(y.getSr()) + ", " + str(y.getSc()) + ", " + str(y.getEr()) + ", " + str(y.getEc()) + "\n"
    dbgFileNode.write(dbgStr)
    
  outString = outString[:-2] + "];\n"

  classNames = set(classNames)
  outString += "classNames = {"
  for n in classNames:
      outString = outString + n + ", " 
  outString = outString[:-2] + "};\n"


  outString = outString + "hasSource = [ \n"
  for source in hasSource:
    outString = outString + str(source) + ", "
  outString = outString[:-2] + "];\n"
  outString = outString + "hasDest = [ \n"
  for dest in hasDest:
    outString = outString + str(dest) + ", "
  outString = outString[:-2] +"];\n"

  maxFuncParams = 0
  outString += "hasParamIdx = array1d(Param, ["
#   for y in sorted(set(sdg.vertexSet()),key=lambda x: x.getId()):
  for y in paramNodes:
    paramID = -1
    if str(y.getKind().toString()) == "FRMI":
      # print(idx2nodeID[int(node)])
      label = str(y.getLabel())
      if "param" in label:
        paramID = int(label.split()[1])
        if paramID > maxFuncParams:
          maxFuncParams = paramID
    if str(y.getKind().toString()) == "FRMO":
      paramID = -1
      for incoming in sdg.incomingEdgesOf(y):
        if str(incoming.getKind().toString()) == "FRMI":
            label = str(incoming.getLabel())
            if "param" in label:
              paramID = int(label.split()[1])
              if paramID > maxFuncParams:
                maxFuncParams = paramID

      
    if str(y.getKind().toString()) == "ACTI":
      paramID = -1
      for outgoing in sdg.getFormalIns(y):
        if str(outgoing.getKind().toString()) == "FRMI":
            label = str(outgoing.getLabel())
            if "param" in label:
              paramID = int(label.split()[1])

    if str(y.getKind().toString()) == "ACTO":
        paramID = -1
        for formalOut in sdg.getFormalOuts(y):
            if str(formalOut.getKind().toString()) == "FRMO":
                for incoming in sdg.incomingEdgesOf(y):
                    if str(incoming.getKind().toString()) == "FRMI":
                        label = str(incoming.getLabel())
                        if "param" in label:
                            paramID = int(label.split()[1])


    outString = outString + str(paramID) + ", "

  outString = outString[:-2] +"]);\n" 
  zincFile.write(outString)
  outString = ""
  zincFile.write("userAnnotatedFunction = array1d(FunctionEntry, [ \n")
  for node in nodeIdx["FunctionEntry"]:
    # print(idx2nodeID[int(node)])
    # print(node)
    if str(idx2nodeID[int(node)]) in anns.keys():
      outString = outString +"true, "
    else:
      outString = outString + "false, "

  outString = outString[:-2] +"]);\n" 

  
  outString += "MaxFuncParms = " + str(maxFuncParams) + ";\n"

  # outString = outString[:-2] +"]);\n" 

  zincFile.write(outString)
  # print("=======")
  CleLabels =  ["nullCleLabel"]
  for annot in anns:
    label = anns[annot][0].split(".")[-1]
    CleLabels.append(label)
    
    zid = nodeID2Idx[int(annot)]
    # print(zid)
    zincFile.write("constraint ::  \"TaintOnNodeIdx" + str(zid) + "\" taint[" + str(zid) + "]=" + label + ";\n" )
    print(anns)      
  zincFile.write("\n\n" )
  
  CleLabels = set(CleLabels)
  outString = ""
  
#   outString = "cleLabel = {"
#   for label in CleLabels:
#     outString = outString + label + ", "
#   outString = outString[:-2] +"};\n"
#   zincFile.write(outString)

  cleOutput = compute_zinc(cles,maxFuncParams)

  with open("cle_instance.mzn", "w") as cle_f:
    cle_f.write(cleOutput[0])
  with open("enclave_instance.mzn", "w") as enclave_f:
    enclave_f.write(cleOutput[1])

  proc = ProcessBuilder("minizinc --solver Gecode ./*.mzn ./constraints/*.mzn > result.txt").start()  


  # rawCle = dumpCLE(args.clpath)
  # rawCle["nullCleLabel"] = "null"
  # #grab all levels
  # levels = ["nullLevel"]
  # for lbl in rawCle:
  #   print(rawCle[lbl])

  # print(cles)
  
  # pp = PrettyPrinter(indent=2)
  # pp.pprint(nodesZinc)
#   pp.pprint(edgesZinc)
#   pp.pprint(anns)


