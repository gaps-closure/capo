# Phase 2 CLOSURE conflict analyzer based on minizinc constraint solver 

Currently a basic sketch in minizinc for testing, analysis, and refinement.

Usage example:
  time minizinc --solver Gecode *.mzn ./testdata/20210804-rkmods/*.mzn

Ideally each future testdata sub-directory should contain:
 1. The generated enclave_instance.mzn, cle_instance.mzn, and pdg_instance.mzn files
 2. The generated debug CSV file
 3. The input annotated C source and the LLVM IR and CLE-JSON derived from it 
 4. An explanation of the test case including any conflicts/errors introduced, and expected result and diagnostics 
 5. Test results using available version of the solver (document the git commit tag)


## Arguing Correctness of the Model in Partitioning CLE-Annotated C programs (using LLVM and PDG)

The conflict analyzer must provide a satisfying assignment of enclaves to each
global variable and function, and identify the call invocation edges in the
cut. A sketch of the arguments for correctness of the constraint model is below
(needs to be vetted).

### OUTPUT CONSTRAINTS

 * All varnode and function node must be assigned an enclave
 * To be in the cut, endpoints of a call edge must be in different enclaves (control return can be safely ignored)
 * All non-annotation nodes must have their (derived) enclave level match their taint level

### ENCLAVE-LEVEL-CONSTRAINTS
 * No non-call edge can leave the enclave
 * No non-return non-param data edge can leave the enclave
 * For each call invocation in the cut, the destination function must be
   annotated and must have a cdf that accept calls from the source enclave
   level
 * For each data return over the cut, the taint of the variable returned must
   allow sharing with destination (caller) function's enclave level
 * For each argument passing in the cut, the taint of the variable going into
   actual-in must allow sharing with destination function's enclave level

### LABEL-CONSTRAINTS

 * Inside an enclave non-data non-return data edge endpoints must have same
   taint or be coercible by an annotated function
 * If function is annotated, the taint of destination of the data return edge
   must be allowed by the rettaints, else the taints across the edge must match
 * If function is annotated, the taint of the variable connected to the actual
   parameter must be allowed by the argtaints for the parameter, else the
   taints across the edge must match  
 * All nodes contained in annotated functions must only have taints that are in
   argtaints, rettaints, and codtaints specified in the corresponding function
   annotation (as parameter and return edges are handled separately above, we 
   primarily need to worry about codtaints) 
 * Unannotated functions can handle at most one taint across all invocations
   that will become the label taint of the function 

Whether the annotations correctly and completely capture data sharing
constraints is out of scope.

Annotated functions must be audited for correctness and to ensure that the 
only information leaving can be shared to the output arguments and return values.
However the program analysis ensures that only these functions (and not the entire
codebase) needs to be scrutinised.

The input preparer prepares the PDG and CLE information for effcicient processing
within MinZinc. Nodes and Edges are grouped by subtype and type and laid out in
sequence so that continguous integer sequences rather than arbitrary sets of IDs
can be used. For convenience, the function that each instruction and parameter
is associated with is also computed and stored.  The parameter indices for formal
in and formal out are also computed and stored.

Note that the input preparer pulls all taints into cleLabel regardless of whether 
there is a JSON (this primarily includes the `TAG_REQUEST_*` and `TAG_RESPONSE_*`
labels that will be defined and used in autogenerated code). The input preparer
also creates a special default label for each enclave without and cdf elements,
and this is not a function blessing annotation. This allows the model to assign
every node a label (including data that has no interference with any cross 
domain interactions).

Only level checking is done on data flowing across the cross-domain functions; 
the downstream verifier will ensure labels are correctly preserved through the 
autogenerated code (not available to this analyzer).

Currently the model forces un-annotated functions to handle only a single
taint across all invocations. As a result, any functions that need to handle
multiple taints across invocations will either need to be annotated to allow
those taints (if safe to do so) or moved out to a library and be checked
separately. [Why: suppose we call an unannotated function with no body taints
with one LABEL1, it stores the value in an unannotated static variable and
could pass it later to a fure call with LABEL1 -- so if the function will
tainted differently across invocations, it needs to be annotated and audited.

